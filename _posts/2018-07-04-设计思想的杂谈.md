---
layout: post
title: 设计思想的杂谈
date: 2018-07-03 00:00:02
categories: 计算机
tags: 设计思想
comments: 1
---





这是关于设计思想的帖子，也就是简单或未成熟的思考。



# 杂谈1

设计思想是什么？[ 菜鸟教程](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)中设计模式的介绍中，有介绍到设计模式的六大原则。

但是这也仅仅是原则，而不是思想。原则是硬邦邦的东西，只要人们遵循它即可，而思想则是知道其原理而自发的行为，因而我不建议看所谓的原则。





# 封装

[封装(面向对象编程)](https://zh.wikipedia.org/zh-sg/%E5%B0%81%E8%A3%9D_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88))

用通俗的语言来讲，就是把内代码裹着，暴露调用的入口。

这种做法，将代码变成“个体”，并且出现调用者和被调用者这种关系。



而长远来看，由共同特征的个体，我们就可以对这些个体同时操作。（如：工厂模式，若干个个体变成一个工厂，工厂模式下可以同时处理它们的初始化前后）





# 刻意练习





# IOC



以前写过不少关于[IOC](https://baike.baidu.com/item/IOC)的文章，今天想谈谈自己怎么在实际情况中领悟IOC。



为了更好的理解，我尝试用问答方式引导。

一）假设有若干个类（A），他们的行为是一致的，然而数据是不一样的，此时你该怎么重构？

答：将数据和行为分开，此时数据类（B）有n份，行为类（C）有1份。



二）原本其他类D对A的调用为这样，D=调用=>n*A

在上题基础下，n\*A变成了(n\*B+C)，那么D该如何调用(n\*B+C)



答：

1. (n\*B+C)该操作在调用前被完成，并将该结果存储下来。（预加载）
2. (B+C)该操作每次都被操作，结果不需要被存储下来。（无存储）
3. (B+C)第一次被执行时候，结果被存储下来，第二次执行时，调用结果。（延迟加载）



预加载和延迟加载需要一个空间储存。这个空间就是数据结构，例如散列。



三）在题（2）预加载的情况下。调用者和被调用者的关系变成怎么样？



原本：

> D1=调用=>类A1
>
> D2=调用=>类A2
>
> D3=调用=>类A3
>
> D4=调用=>类A4



IOC

> D1=通过标识A1调用=>容器
>
> D2=通过标识A2调用=>容器
>
> D3=通过标识A3调用=>容器
>
> D4=通过标识A4调用=>容器
>
> （标识可以是字符串）
>
> 预加载
> 数据B1+C类=载入=》容器
>
> 数据B2+C类=载入=》容器
>
> 数据B3+C类=载入=》容器
>
> C类为没有具体数据的行为类。



四）IOC和多线程

通过容器进行解耦这种思想，在多线程中内常常体现，毕竟为了达到扩展的效果。



# 约定优于配置（1）

“约定优于配置”（convention over configuration ），常见的例子是spring boot和Ruby on Rails等框架。



对于“约定优于配置”，我认为不能二元论的判断“好与坏”。就从根本来说，我们的一切知识都是基于约定，就像编程语言的语法一样，所以，我们一直都再遵守某种约定。而所谓的约定，是某个或者某几个组织所制定的，具有主观意识的存在。而这种主观意识是会改变的，而恰恰是因为编程相关的理论没有所谓的绝对真理，变动不小，所以这种主观意识是不稳定的。这就是“约定”的不稳定性。

而迫于技术人员对效率的需求，常常会制定“约定”，以减少代码量。而常常因为技术人员的能力以及时间问题，这种“约定”和新人所认识的“约定”常常出现分歧，也就会导致学习成本的增加。（组织越小，技术越不精，也意味着这“约定”会更加偏离）

这意味着“约定优于配置”要根据具体的框架来进行判断，不能单一判断。

“约定优于配置”常常需要考虑扩展性，而“约定”的制作者又常常站在自己的角度进行分析，就需要更多的反馈才能开放出一个扩展性良好的框架。（当然也是要技术和理论）



2018-07-10



# 约定优于配置（2）

正因为万物都有“规定”，而设计模式的出现就常常因为这种“规定”不符合需求，而出现的一种拆分重组的方案。



2018-07-10





# 插件，钩子

> 钩子是插件执行的触发器；插件就像挂在钩子上的东西； 

评论：真多术语。



