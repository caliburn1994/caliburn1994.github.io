---
layout: post
title: Java密码学 - 9.数字信封
date: 2017-08-13 19:37:37
categories: 计算机
tags: 安全 
comments: 1
---

数字信封是将[对称密钥](https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5/7453635)通过[非对称加密](https://baike.baidu.com/item/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/9874417)（即：有[公钥](https://baike.baidu.com/item/%E5%85%AC%E9%92%A5/6447788)和[私钥](https://baike.baidu.com/item/%E7%A7%81%E9%92%A5/8973452)两个）的结果分发对称密钥的方法。数字信封是实现信息完整性验证的技术。

##### 原理

[传送门](http://www.cnblogs.com/franson-2016/p/5520675.html)

> 信息发送者首先利用随机产生的【对称密码】加密信息(因为非对称加密技术的速度比较慢)，再利用接收方的【公钥】加密对称密码，被公钥加密后的对称密钥被称之为数字信封。在传递信息时，信息接收方要解密信息时，必须先用自己的私钥解密数字信封，得到对称密码，才能利用对称密码解密所得到的信息。


根据原理，我们需要以下参数：

1. 对称密钥或者对称密钥的生成算法
2. 对方的公钥  (证书里含有)
3. 正文(内容)

<br>


getCertificateChain这方式就是获取证书的array

##### 代码

证书的获取途径：

- pem格式
- keystore提取

<br>

使用的工具包：[org.bouncycastle.cms (Bouncy Castle Library 1.57 API Specification)](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwiMs73m-qXVAhXEGpQKHSf3BW0QFggnMAA&url=https%3A%2F%2Fwww.bouncycastle.org%2Fdocs%2Fpkixdocs1.4%2Forg%2Fbouncycastle%2Fcms%2Fpackage-summary.html&usg=AFQjCNGCxt5MIpwC5mPhgLsiqKHcccONZw)

代码实现：**生成数字信封**（在BC的源码可见）


```java
//CMS是消息加密语法
//数据处理
CMSTypedData msg = new CMSProcessableByteArray(需要签名的内容);
//生成信封
CMSEnvelopedDataGenerator edGen = new CMSEnvelopedDataGenerator();
edGen.addRecipientInfoGenerator(new JceKeyTransRecipientInfoGenerator(cert)//证书(含公钥)
		.setProvider("BC"));
		CMSEnvelopedData ed = edGen.generate(
				msg,
				new JceCMSContentEncryptorBuilder(CMSAlgorithm.DES_EDE3_CBC) //对称加密的算法
						.setProvider("BC").build());
```

代码解析

```
edGen.addRecipientInfoGenerator(new JceKeyTransRecipientInfoGenerator(cert)
.setProvider("BC"));
```

是将证书里的内容提取出来，再将内容转换成BC的结构 (原：java.security包下的)。

证书里的内容：

1. 公钥 (进行加密)
2. Issuer 发行者 SerialNumber 发行者序列 (识别)

##### <br>

代码实现：**获取数字信封内容**

```java
public byte[] openEnvelope(PrivateKey prikey) throws Exception {
	Security.addProvider(new BouncyCastleProvider());
	PEMParser pr = new PEMParser(new FileReader(envfile));
	ContentInfo o = (ContentInfo) pr.readObject();//读取PEM格式的数字信封

	//获取密文
	CMSEnvelopedData ed = new CMSEnvelopedData(o.getEncoded());
	RecipientInformationStore recipients = ed.getRecipientInfos();

	//解密
	ArrayList list = (ArrayList) recipients.getRecipients();//接收人们的信息
	RecipientInformation recipient = (RecipientInformation) list.get(0);//获得第一个接收人
	
	return recipient.getContent(new JceKeyTransEnvelopedRecipient(prikey).setProvider("BC"));
	
	}
```

PS：代码必须设置BC作为提供者

```
Security.addProvider(new BouncyCastleProvider());
```