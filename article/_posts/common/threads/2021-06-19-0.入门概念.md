---
layout: post
title: 并行并发 - 0.概念介绍
tags: [Common]
series: "并行并发"
comments: 1
typora-root-url: ..\..\..\..
typora-copy-images-to: ..\..\..\..\assets\blog_res\concurrency
---



## 并行性 parallelism

**并行性**（parallelism） 是指 同时做若干件事情。<sup>[go talk](https://talks.golang.org/2012/waza.slide#8)</sup>  如下图所示，多个 CPU（central processing unit）或者 一个CPU内的多个 core，可以同时执行若干件事情：

![image-20210717202716201](/assets/blog_res/concurrency/image-20210717202716201.png)

在 [Oracle 的官方教程](https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html)中，介绍到，并行计算（Parallel computing）是将一个问题，拆分成若干个子问题（每一个子问题在一个单独的 thread 中执行），同时解决这些子问题，然后合并其结果，并传递给下一个子问题。

如下例所示，使用 `parallelStream` *并行*地运行着Streams。

```java
double average = roster
    .parallelStream()
    .filter(p -> p.getGender() == Person.Sex.MALE)
    .mapToInt(Person::getAge)
    .average()
    .getAsDouble();
```

从上例，我们可以看得出，具有并行性（parallelism）的事情往往具有共同的特点。

并行性（parallelism）所指代的事情往往是：

- 无状态机器（finite-state machine），没有所谓的状态。如：批处理、HTTP请求等等

- 事情 之间没有任何关联。不存在 事情A 需要等待 事情B 完成。





## 并发性 Concurrency

**并发性**（Concurrency） 是指打算做若干件事情<sup>[go talk](https://talks.golang.org/2012/waza.slide#8)</sup>，但实际上只能一件一件地做。

![image-20210717205740228](/assets/blog_res/concurrency/image-20210717205740228.png)

在计算机地世界，由于事情间可以快速切换（上下文切换），所以我们有一种错觉——同一时刻我们在做着若干件事情。由于一个 CPU（central processing unit）拥有若干个核（core），在一个时间点，一个核（core）只能做一件事情。

- 由于操作系统可以上下文切换（Context switch），所以我们可以说，单核（single core）具有并发性。
- 由于进程中的线程，以上下文切换（Context switch），我们可以说，进程具有并发性。
- 如果线程中有若干个协程（或纤程），我们也可以说，线程具有并发性。



### 并发和并行 Relationship

严格意义上，如果多个 core 执行 *并发任务* 时，该任务也可以被称为 *并行任务*。但 *并行任务不一定是并发任务*，并行任务们之间如果没有产生交点，它们实质上就和 单个 CPU 的程序、单个 core 的主线程没有任何差异。因此，我们在讨论 *并行* 时，往往是着眼于 任务 霸占了多少个 core 、kernel thread。

而讨论 **并发**（Concurrency）时，着眼在 *交点该怎么处理* 以及相关的 *CPU如何更高效地利用*。

另一个关于两者区别的例子如下

- 如果一个主线程，开启了若干条子线程，他们之间没有任何交点，并结束，那么这若干条子线程之间就是*并行*。
- 如果主线程必须等待子线程的任务结束，才能继续执行下一步，那么主线程和子线程之间就是*并发*。

### 控制流 Control flow

多控制流（[Control flow](https://en.wikipedia.org/wiki/Control_flow#Async)）的处理方案包含：异步方法调用（Asynchronous method invocation）、同步（Synchronization）等。

#### 异步方法调用 Asynchronous method invocation

异步（Asynchrony ）：Flow-A 执行异步，启动了一个 Flow-B，Flow-B 还没执行完，仅仅返回某种标志（可能是 信号、引用），Flow-A 得到该标志并继续执行（没有被堵塞 Non-blocking）。

常见的异步有：

- 函数级别：异步回调函数（[Asynchronous callback function](https://kyakya.icu/article/callback)、[Asynchronous method invocation](https://en.wikipedia.org/wiki/Asynchronous_method_invocation)）。如：`java.util.concurrent.future`
- 应用级别：（将 compute 操作交给其他服务器）
  - 用于浏览器加载的 [Ajax](https://en.wikipedia.org/wiki/Ajax_(programming))（asynchronous [JavaScript](https://en.wikipedia.org/wiki/JavaScript) and [XML](https://en.wikipedia.org/wiki/XML)）
  - 消息队列（如：RabbitMQ ）

![enter image description here](/assets/blog_res/concurrency/H5ysA.png)

####  同步 Synchronization

同步（Synchronization）分为两种：执行同步（synchronous execution）、数据同步，这里就 *执行同步* 进行讨论。**执行同步** 实际要达到的效果是 action（如线程） 按照一定顺序进行执行。

常见同步有：

- 汇合（join up）。如下图：主线程和子线程进行汇合。

  ```java
  Thread thread1 = new Thread(new Runnable() {
      @Override
      public void run() {
  		// do sth
      }
  });
  
  // 子线程与主线程进行汇合
  // 在汇合之前，
  thread1.join();
  ```

  ![enter image description here](/assets/blog_res/concurrency/GVMMy.png)

## 延申 & 参考

- [What is the difference between concurrency, parallelism and asynchronous methods? - StackOverflow](https://stackoverflow.com/a/48530284/4883754)   
- [Asynchrony (computer programming) - wiki](https://en.wikipedia.org/wiki/Asynchrony_(computer_programming))
- [Synchronization (computer science) - wiki](https://en.wikipedia.org/wiki/Synchronization_(computer_science))
- [Asynchronous method invocation](https://en.wikipedia.org/wiki/Asynchronous_method_invocation)
- [Javascript的定时器是多线程的吗？- 知乎](https://www.zhihu.com/question/308612651)








