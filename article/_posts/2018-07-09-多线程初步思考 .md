---
layout: post
title: 多线程初步思考
date: 2018-07-09 00:00:00
categories: 计算机
tags: 多线程 
comments: 1
---





## 章节1

一）前提

对象是由数据和行为构成。

二）目的

多线程下，可以同时有几个行为影响同一个数据。

三）解决方案

于是乎出现锁（single threaded execution），限制行为。

<br>

## 章节2

一）前提

数据的操作分为读和写。读操作往往是[幂等](https://baike.baidu.com/item/%E5%B9%82%E7%AD%89)，写操作则非幂等。

二）策略

根据数据分类：

1. 数据读：写=1：1

   这种数据往往可以用容器进行存储，可存储若干个。

   优化：减少行为之间的等待。通过异步方式实现。

   Golang使用CSP(Communicating Sequential Process) 模型就有点这种气味。

2. 数据读：写=n：1

   - 该数据往往只有一份，不以容器进行存储。通过优化锁，可以达到提高性能。读和写互斥，写之间互斥，读之间不互斥（优化读）。
   - 即时性要求不高时。通过两个数据副本的方式可以减少行为间的等待时间。即将数据分为两个副本，读和写各持一个，以减少等待时间成本。

<br>

## 章节3

颗粒度下降为行为：

二）问题：行为间如何通讯？

1）行为间的优先级

- 通过等待(wait)和唤醒(notify)机制。

    调整优先级的策略

  - 守卫者模式，通过while循环模式，进行调整
  - barking模式，不wait，直接结束。（一次性）

2）终止行为/终止线程（颗粒度为线程或对象）



<br>

## 章节4

代码重构。

1）通过代理模式，对单线程对象进行重构，使之成为多线程对象。这种操作适合于线程/对象的行为之间没有交流。

<br>

## 章节5

工程的规模越来越大，从“面向对象”到“面向组件”，再到“面向服务”，虽然规模越来越大，封装程度也越来越大，希望使模型变得更为简单易用。而在多线程开发中也似乎有这种倾向，actor模型就是这样的。它倾向于封装线程，并赋予行为以便交流。（颇有面向服务的感觉）

就拿Email来说，Email一般是有接受服务器和发送服务器，同样的，actor也是有“服务器”（实质为容器）进行管理。