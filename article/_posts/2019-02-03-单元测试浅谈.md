---
layout: post
title: 单元测试浅谈
date: 2019-2-03 23:55:01
categories: 计算机
tags: 设计思想
comments: 1
typora-root-url: ..
excerpt: 单元测试浅谈
---



单元测试是好是坏以及使用方法，一直都是软件工程中的话题。就该话题，我们进行讨论。

## 推荐文章

王垠大神的：[测试的道理](http://www.yinwang.org/blog-cn/2016/09/14/tests)

[@middlefeng](https://twitter.com/middlefeng)： [关于单元测试](https://techsingular.net/2012/09/04/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/)

<br>

## 争论点

单元测试的支持者认为，单元测试可以帮助程序员在未来修改代码时，更容易*发现错误*和*定位错误*。我们就这点进行展开讨论。

<br>

### 发现错误（防止bug）

BUG的出现，往往在于编写代码者没有注意到一些分支，而单元测试起到*自省*的作用。但是具有自省作用的方法并不是只有一种。有：

1. 单元测试
2. 画图
3. 注释

<br>

画图（2）可以提供宏观的自省，而代码里编写注释（3）可以起到细节的自省。两者可以均可减少bug。而在开发阶段，单元测试起到的自省功能与注释（3）无区别。

#### 注释

通过注释的方式，在一些代码细节，我们进行了第一次**彻底的自省**后就不需要编写单元测试（二次自省）。而有的项目组拥有review code的习惯，因此这些项目组对代码进行了*二次自省*。

#### 画图

通过画图的方式，架构师可以确认代码的大致方向，并可以根据该方向进行检验Git提交上来的代码意义。这个过程既是重构，也是代码大方向上的自省。虽然单元测试也是能提供框架上的自省，但是作用没有画图那么具有强烈目的性，并且单元测试常常被拘束在原有的思维上。

<br>

### 发现错误（代码改动）

当代码改动时，单元测试有效的帮助我们发现并且定位错误。然而，单元测试的编写以及维护是需要成本的。

公式：收益（时间） = { 发现错误收益 + 定位错误 } - {  单元测试编写 + 单元测试的维护 }

1.

项目初期，框架不稳定。

> 单元测试维护成本高（↑），收益低（↓）

<br>

2.

编写类似GUI的单元测试，因为测试难度高，所以性价比低。某种意义而言，这也意味着GUI等内容的配套工具未成熟到方便测试的程度。

> 单元测试编写成本高（↑），收益/性价比低（↓）

<br>

3.

也就是，当我们一眼就可以看出某些 测试结果时，使用单元测试（自动化）就显得收益比较差。

> 单元测试的收益（时间） = 自动化发现错误 - 人工发现错误

<br>

### 定位错误

单元测试在发现问题的角度上，表现良好，因为它的存在体现了代码具有模块性。但是相反，作为代码模块并不一定需要单元测试——单元测试的颗粒度不应该是有教条的（不应该单纯地根据method）。

1. 代码功能很有可能是重复的，尽可能避免这些无用功。
2. 代码的覆盖可以通过数学方式进行判断。（子集、并集等）

<br>

## 手法&工具

### stub

stub的经典例子：（from：[How to use stubs in JUnit and Java?](https://stackoverflow.com/questions/31890991/how-to-use-stubs-in-junit-and-java)）

```java
interface Service {
    String doSomething();
}

class ServiceStub implements Service {
    public String doSomething(){
        return "my stubbed return";
    }
}
```

在这个例子中，stub通过实现了接口的方式，从而模拟外部依赖。

stub的使用，符合[TDD(Test-driven development)](#TDD)的使用习惯——在编写代码的时候思考测试该如何编写。通过编写stub，我们将会明白：

*[TDD]: 测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。

- 外部依赖应通过插入的方式进行添加（单元测试共性）。
- 通过接口的方式进行解耦，防止代码改动导致测试代码的不可用。（**如下图**）



![1548175343708](/../assets/blog_res/1548175343708.png)

<br>

### mock

若是将stub比作白盒测试，那么mock就是黑盒测试。在使用mock时，你根本不了解该类，而是单纯想在单元测试中使用而已。

![1548180320941](/../assets/blog_res/1548180320941.png)

从上图可知，mock不面向接口，面向的是具体的类或者对象，因此容易受到代码改动的影响。对比起内部代码，外部代码（尤其已经成熟的框架）往往[更稳定](#更稳定)不易被修改，所以可以采取mock的方式。

*[更稳定]: 框架往往是向下兼容的，且项目依赖的框架往往不会升级。

从另一个角度分析，接口的用途在于向外暴露，而暴露的方式有两种：

- 主动暴露

- 被动暴露


Java使用的是主动暴露接口，生产者实现定义好接口，调用者从外部进行调用。接口的定义权完全取决于生产者。也正因为定义权取决于生产者，所以调用方往往处于被动的地位，因此带来以下后果：

1. 生产方的接口的改动会影响调用方。

2. 为了避免由于（1）点所造成的兼容性问题，一些设计者可能设计若干个接口，这样增加了调用者理解的成本。同时，由于Java实现往往依赖继承（层数过高），所以源代码也常常难以查看。
3. 类必须实现接口所有方法，构造stub成本随着方法的数量增多而变难。

综上所述，stub也存在一定的问题，而解决这些问题的mock也拥有了不少的应用场景。但是最理想的方案是，外部依赖自己提供单元测试的模块，供调用方使用。

<br>

### 总结

stub：适合项目内依赖。

mock：适合项目外部依赖，但是理应优先使用外部依赖提供的测试工具模板。
