---
layout: post
title: 单元测试浅谈
date: 2019-2-03 23:55:01
categories: 计算机
tags: 设计思想
comments: 1
typora-root-url: ..
excerpt: 单元测试浅谈
---



单元测试是好是坏，该怎么用，一直都是软件工程中的话题。就该话题，我们进行讨论。

## 推荐文章

王垠大神的：[测试的道理](http://www.yinwang.org/blog-cn/2016/09/14/tests)

[@middlefeng](https://twitter.com/middlefeng)： [关于单元测试](https://techsingular.net/2012/09/04/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/)

<br>

## 争论点

单元测试的支持者认为，单元测试可以帮助程序员在未来修改代码时，更容易*发现错误*和*定位错误*。

<br>

### 发现错误（防止bug）

问题的出现，往往在于编写代码者没有注意到一些分支，也就是说单元测试起到*自省*的作用。而起到自省作用的方法并不是只有一种。有：

1. 单元测试
2. 通过画图
3. 注释

<br>

画图（2）可以提供宏观的自省，而代码里编写注释（3），可以有助于代码细节的自省。两者可以起到减少bug的作用。而在开发阶段，单元测试起到的自省功能与注释（3）无区别。

通过注释的方式，在一些代码细节，我们进行了第一次**彻底的自省**后，代码就不需要编写单元测试。而有的项目组拥有review code的习惯，因此这些项目组对代码进行了*第二次自省*。

通过画图的方式，架构师可以确认代码的大致方向，并可以根据该方向进行检验Git提交上来的代码意义。这个过程既是重构，也是代码大方向上的自省。虽然单元测试也是能提供框架上的自省，但是作用没有画图那么具有强烈目的性，并且单元测试常常被拘束在原有的思维上（就如同，使用Java的写的代码和使用Go写的代码是完全不同）。

小结：经历完全自省的代码，不需要单元测试。

<br>

### 发现错误（代码改动）

当代码改动时，单元测试有效的帮助我们发现错误，并且定位错误。然而，成本是单元测试的编写，以及当代码改动时，单元测试会不会需要改变。

公式：收益（时间） = { 发现错误收益 + 定位错误 } - {  单元测试编写 + 单元测试的改动 }

1.

单元测试改动成本（↑），收益（↓）

这种情况出现于项目初期，项目框架不稳定。

<br>

2.

单元测试编写（↑），收益（↓）

编写关于GUI等的单元测试，因为难以测试，所以收益很差。某种意义而言，这也意味着GUI等内容的工具未成熟到方便测试的程度。

<br>

3.

发现错误收益（时间） = 自动化发现错误 - 人工发现错误

也就是，当我们一眼就可以看出某些 测试结果时，使用单元测试（自动化）就显得收益比较差。

<br>

### 定位错误

单元测试在发现问题的角度上，表现良好，因为它的存在体现了代码具有模块性。但是相反，作为代码模块并不一定需要单元测试——单元测试的颗粒度不应该是有教条的（不应该单纯地根据method）。

1. 代码功能很有可能是重复的。
2. 代码的覆盖可以通过集合的形式表示。（子集和超集）

这是从效率以及代码出Bug的可能性一角度出发思考的。

<br>

## 手法&工具

### stub

stub的经典例子：（from：[How to use stubs in JUnit and Java?](https://stackoverflow.com/questions/31890991/how-to-use-stubs-in-junit-and-java)）

```java
interface Service {
    String doSomething();
}

class ServiceStub implements Service {
    public String doSomething(){
        return "my stubbed return";
    }
}
```

在这个例子中，stub使用并实现了接口，而在单元测试时，代码通过调用该stub（用于代替外部依赖）从而完整了整个测试。

stub的使用，符合[TDD(Test-driven development)](#TDD)的使用习惯——在编写代码的时候思考测试该如何编写。通过编写mock，明白：

*[TDD]: 测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。

- 外部代码需要通过插入方式添加（单元测试共性）。
- 通过接口进行解耦，防止代码改动导致测试代码的不可用。（**如下图**）



![1548175343708](/../assets/blog_res/1548175343708.png)

<br>

### mock

若是将stub比作白盒测试，那么mock就是黑盒测试。在使用mock时，你根本不了解该类，而是单纯想在单元测试中使用而已。

![1548180320941](/../assets/blog_res/1548180320941.png)

从上图可知，mock不面向接口，面向的是具体的类或者对象，因此容易受到代码改动的影响。对比起内部代码，外部代码（尤其已经成熟的框架）往往[更稳定](#更稳定)不易被修改。

*[更稳定]: 框架往往是向下兼容的，且项目依赖的框架往往不会升级。

从另一个角度分析，接口的用途在于向外暴露，而暴露的方式有两种：主动暴露和被动暴露。Java使用的是主动暴露接口，生产者实现定义好接口，调用者从外部进行调用。接口的定义权完全取决于生产者。

也正因为定义权取决于生产者，所以调用方往往处于被动的地位。

1. 生产方的接口的改动会影响调用方。

2. 为了避免由于（1）点所造成的兼容性问题，一些设计者可能设计若干个接口，这样增加了调用者理解的成本。同时，由于Java实现往往依赖继承（层数过高），所以源代码也常常难以查看。
3. 类必须实现接口所有方法，构造stub成本随着方法的数量增多而变大。

因为这些原因，mock也拥有了相当多的应用场景。但是最理想的方案是，外部依赖自己提供单元测试的模块，供调用方使用。

<br>

### 总结

stub：适合项目内依赖。

mock：适合项目外部依赖，但是理应优先使用外部依赖提供的测试工具模板。

<br>

