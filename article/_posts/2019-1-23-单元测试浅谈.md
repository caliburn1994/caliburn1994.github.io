---
layout: post
title: 单元测试浅谈
date: 2019-1-23 23:55:01
categories: 计算机
tags: 设计思想
comments: 1
typora-root-url: ..
excerpt: 单元测试浅谈
---





## 单元测试 unit testing

> 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。
>
> <div align="right">from wiki</div>

<br>

## 常见用法

### stub

stub的经典例子：（from：[How to use stubs in JUnit and Java?](https://stackoverflow.com/questions/31890991/how-to-use-stubs-in-junit-and-java)）

```java
interface Service {
    String doSomething();
}

class ServiceStub implements Service {
    public String doSomething(){
        return "my stubbed return";
    }
}
```

在这个例子中，stub使用并实现了接口，而在单元测试时，代码通过调用该stub（用于代替外部依赖）从而完整了整个测试。

stub的使用，符合[TDD(Test-driven development)](#TDD)的使用习惯——在编写代码的时候思考测试该如何编写。通过编写mock，明白：

*[TDD]: 测试驱动开发（英语：Test-driven development，缩写为TDD）是一种软件开发过程中的应用方法，由极限编程中倡导，以其倡导先写测试程序，然后编码实现其功能得名。测试驱动开发始于20世纪90年代。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。

- 外部代码需要通过插入方式添加（单元测试共性）。
- 通过接口进行解耦，防止代码改动导致测试代码的不可用。（**如下图**）



![1548175343708](/../assets/blog_res/1548175343708.png)

<br>

### mock

若是将stub比作白盒测试，那么mock就是黑盒测试。在使用mock时，你根本不了解该类，而是单纯想在单元测试中使用而已。

![1548180320941](/../assets/blog_res/1548180320941.png)

从上图可知，mock不面向接口，面向的是具体的类或者对象，因此容易受到代码改动的影响。对比起内部代码，外部代码（尤其已经成熟的框架）往往[更稳定](#更稳定)不易被修改。

*[更稳定]: 框架往往是向下兼容的，且项目依赖的框架往往不会升级。

从另一个角度分析，接口的用途在于向外暴露，而暴露的方式有两种：主动暴露和被动暴露。Java使用的是主动暴露接口，生产者实现定义好接口，调用者从外部进行调用。接口的定义权完全取决于生产者。

也正因为定义权取决于生产者，所以调用方往往处于被动的地位。

1. 生产方的接口的改动会影响调用方。

2. 为了避免由于（1）点所造成的兼容性问题，一些设计者可能设计若干个接口，这样增加了调用者理解的成本。同时，由于Java实现往往依赖继承（层数过高），所以源代码也常常难以查看。
3. 类必须实现接口所有方法，构造stub成本随着方法的数量增多而变大。

因为这些原因，mock也拥有了相当多的应用场景。但是最理想的方案是，外部依赖自己提供单元测试的模块，供调用方使用。

<br>

### 总结

stub：适合项目内依赖。

mock：适合项目外部依赖，但是理应优先使用外部依赖提供的测试工具模板。

<br>

## 必要性

在说到测试，我们往往期望测试代码能帮我们测试到每一个角落，以达到“机器取代测试员”的效果。然而在正式编写单元测试时，我们开始怀疑这种期望的可行性。

以下是一些参考的文章：

- https://zhuanlan.zhihu.com/p/35508972

<nr>

## 例子（探讨）

### CRUD（增删改查）的单元测试

**探讨：该如何编写单元测试**

思路：

为了达到测试的稳定性，可以

- 模拟数据库
- 不测试数据库

**模拟数据库**

<p class="cxj_code">

```java
class UserAddbiz{
    
    AbstractDao dao
    
    pulic void run(User user){
        String rsl=null;
        if(条件){
             dao.add(user) 
        }else{
            rsl="error"
        }        
    }
    
    public testRun(){
        UserAddbiz biz = new UserAddbiz();
        biz.setDao(stubDao);//输入模拟数据库（stub/mock）
        biz.run(user)
    }  
    
}
```

**不测试数据库**

<p class="cxj_code">

```java
class UserAddbiz{
    
    AbstractDao dao
    
    pulic void run(User user){
        String rsl=null;
        if(isTrue(user)){
             dao.add(user) 
        }else{
            rsl="error"
        }        
    }
    
    public String isTrue(User user){
        //条件判断
        return rsl;
    }
    
    public testIsTrue(){
    	String rls= isTrue(new user(数据));
        assert//判断rsl
    }      
}
```

*区别*在于：后者不测试dao的method。

探讨：

mock和stub的作用在于隔绝外部依赖，从而达到绝对的控制条件。从另外的角度看，若是真正要测试的内容被wrapped的话，我们测试时砍掉前面和后面的代码也能达到同样的结果，并且这种行为更方便编写。

因此，从这个角度上看，我不认同网上所谓的一刀切，private method和protect method不测。当然，在非wrapped形式的代码上，使用stub和mock更为合适

<br>

## 小结

- 世人常说的单元测试，其实不是纯粹的单元测试，而是*单元测试+集成测试*

- stub和mock常常用于单元测试，stub更易于代码的重构。
- stub和mock并非必要的，适当时候我们可以抽取真正的内容，封装成method，并针对该内容进行测试。

