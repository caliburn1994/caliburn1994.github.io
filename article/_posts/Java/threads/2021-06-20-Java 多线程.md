---
layout: post
title: Java多线程-1.锁
tags: [Java-Threads]
comments: 1
typora-root-url: ..\..\..\..
typora-copy-images-to: \assets\blog_res\java\threads
---



## 普通锁

### synchronized 

**static method级别**

```java
public synchronized static void staticMethod(){}
```

**method级别**

```java
// (1)
public synchronized void method(){}
// (2)
class MyClass{
    public void method(){
        synchronized (this) {
            //sth
        }
    }
}
```

*区别*：(2)被覆盖后，是*可以选择取消锁*，(1)的方式被覆盖后，仍旧选择取消锁与否。

扩展：

- [Vector](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/Vector.html) 的锁是 method级别，因此我们无法取消锁。且，Vector 为所有 method 加锁，因此效率低。

**code block级别**

```java
class MyClass{
    final Object mutex1=new Object();
    final Object mutex2=new Object();
    
    public void method1(){
        synchronized (mutex1) {
            //sth
        }
    }
    
    public void method2(){
        synchronized (mutex2) {
            //sth
        }
    }
}
```

扩展：

- `Collections.synchronizedList(List)` 的锁属于 code block级别，因此存在（复杂）继承等关系，即拥有*扩展性*。

**特定**

```java
public class MyClass{
    public AtomicInteger atomicInteger = new AtomicInteger();

    public static void main(String[] args) {
        MyClass demo = new MyClass();
        AtomicInteger integer = demo.atomicInteger;
        integer.incrementAndGet();
        
        System.out.println(integer);
    }
}
```

```kotlin
fun main() {
    val counter = AtomicInteger();
    counter.incrementAndGet()

    println(counter)
}
```





## 数组 Arrary

### Vector

[Vector](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/Vector.html)  (矢量、向量) 是一个动态数组，与 [ArrayList ](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/ArrayList.html) 的区别：

- [Vector](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/Vector.html) 是线性安全<sup>thread safe</sup>，但 **Vector synchronize 几乎所有的 methods**，包含读操作与写操作 ，所以效率差。一般而言，*读操作之间不应该互相 synchronized*。ArrayList 不是线性安全<sup>thread safe</sup>

```java
// 增
public synchronized boolean add(E e) {
    modCount++;
    add(e, elementData, elementCount);
    return true;
}
// 查
public synchronized E get(int index) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
// 更
public synchronized E set(int index, E element) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
}
// 删
public synchronized E remove(int index) {
    //....
}
```

- vector  容量不足的时候，将会翻倍。

  > the capacity of the vector is doubled each time it needs to grow.

  [ArrayList](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/ArrayList.html) 容量不足，将是增加  50%。

  > Returns a capacity at least as large as the given minimum capacity. Returns the current capacity increased by 50% if that suffices. 

<br>

另外：

[Vector](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/Vector.html)  缺少 <u>insert if not exists</u>、<u>update if exists</u> 、<u>insert or update if exists</u>  三个操作，所以在使用时需要注意。

###  Collections.synchronizedList

```java
static class SynchronizedCollection<E> implements Collection<E>, Serializable {
    
    final Object mutex;     // Object on which to synchronize
	...
    public E get(int index) {
        synchronized (mutex) {return list.get(index);}
    }
    public E set(int index, E element) {
        synchronized (mutex) {return list.set(index, element);}
    }
    public void add(int index, E element) {
        synchronized (mutex) {list.add(index, element);}
    }
    ...
}
```

